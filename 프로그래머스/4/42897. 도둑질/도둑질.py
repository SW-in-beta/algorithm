"""
털긴 왜털어...인접한 두집을 털면 안된다
느낌이 이 집을 털었을 때 안털었을 때 기준으로 추가해가야 할 것 같은데
문제는 원형이라는 점
집이 3개 이상 10**6개 이하
원소는 0이상 1000이하

이 집을 털었을 때 max, 이집을 안털었을 때 max
그 다음 집을 털때는 ((이전 집을 안털었을 때 max + 자기 자신), (이전 집을 털었을 때 max)) 뭐 이런식으로 계산하면 될 것 같다.
근데 마지막집일 경우에는? 첫 집의 경우까지 고려해야한다. 첫 집을 안털고를 고려해야 하는데, 그럼 경우의 수는 꽤 많아질 것 같음

생각해보자.
결국 마지막 집 구할 때 필요한 것은 첫집을 털었냐 안털었냐 + 이전집을 털었냐 안털었냐.
각 dp에는 4가지 경우가 저장되어야 할 것 같다.
1. 첫집 털고 내집 털고 -> 둘째집에는 0으로 해놓으면?
2. 첫집 털고 내집 안털고
3. 첫집 안털고 내집 털고
4. 첫집 안털고 내집 안털고

dp[i]를 구하기 위해 필요한 정보를 생각해보자.
1. 첫집 털었나?
2. 이전집 털었나?

max 값은 나를 포함하냐 안포함하냐 버전으로 두개 갖고 있어야 하긴 한다.

단계를 분석해보자.
내 차례가 왔을 때 고려해야할 점은 나를 포함해서 최댓값, 나를 포함하지 않고 최댓값.
어떻게 구하나? -> 나를 포함해서 최댓값은 이전 집을 포함하지 않는 최댓값 + 나
나를 포함하지 않고 최댓값은 이전 집을 포함하는 최댓값

여기에 이제 첫 집의 여부가 추가되는거지
1.첫집 + 나 = 첫집 - 이전집 + 나
2.첫집 - 나 = max(첫집 + 이전집, 첫집 - 이전집)
3.-첫집 + 나 = -첫집 - 이전집 + 나
4.-첫집 - 나 = max(-첫집 + 이전집, -첫집 - 이전집)

이렇게 구할 수 있다.

"""

def solution(money):
    dp = [[[0, 0], [0, 0]] for _ in range(len(money))]
    dp[1][0] = [0, money[0]]
    dp[1][1] = [money[1], 0]
    
    for i, m in enumerate(money[2:], start=2):
        dp[i][0] = [dp[i-1][0][1] + m, max(dp[i-1][0])]
        dp[i][1] = [dp[i-1][1][1] + m, max(dp[i-1][1])]
        
    return max(dp[len(money)-1][0][1], *dp[len(money)-1][1])