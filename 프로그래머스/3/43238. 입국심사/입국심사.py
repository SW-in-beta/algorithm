"""
n은 1명 이상 10**9 -> O(n)으로 끝내야 한다.
심사 시간도 <= 10**9
심사관은 1명 이상 10**6 이하

심사관 기준으로 뭔가를 진행해야 할 것 같다.
최대 시간을 정해놓고, 각 심사관들이 몇명 처리가능한지 구하고
그보다 크면? 오른쪽 탐색. 작으면? 왼쪽 탐색
이 방식의 시간 복잡도 -> log_2(10**9) * 10**6 -> 되겠다.

조금 더 구체화하기. 심사를 받는데 걸리는 시간을 최소로.
같은 경우를 생각해야한다. -> 최소니까 같으면 자기자신 포함해서 왼쪽만 탐색하도록
작아도 자기자신 포함해서 왼쪽을 탐색할 수 있어야 한다.
큰경우는 해당 값을 포함시키면 안되니까 left를 mid+1로.
ㅇㅋ left < right일때까지만

일단 시간초과는 안난다. 왜 틀렸는지 논리적으로 분석해보자.
설계 이유
최솟값을 구하는거다. 그래서 가장 작은 값이 필요
현재 상황
l과 r에는 가능성 있는 후보 전체가 들어있다.
처리해야할 사람 수 <= 현재 시간에서 처리할 수 있는 사람 수 : 즉 지금 시간이 포함될수도 있고, 이것보다 작을수도 있는 상황 -> r을 m과 같도록 땡겨온다. 그래야 포함될 수 있음
처리해야할 사람 수 > 현재 시간에서 처리할 수 있는 사람 수 : 현재 시간은 절대 포함될 일 없다. -> 그래서 l을 이것보다 크게

count는 제대로 작동하고 있는게 맞나? -> 기준 시간이 주어졌을 때, 그 시간까지 처리할 수 있는 사람을 전부 더하기. 맞다.


"""
def count(t, times):
    return sum(t // time for time in times)

def max_time(n, times):
    return max(times) * n

def solution(n, times):
    l = 0
    r = max_time(n, times)
    answer = 0
    while l <= r:
        m = (l + r) // 2
        cnt = count(m, times)
        if n <= cnt:
            answer = m
            r = m - 1
        else:
            l = m + 1
    return answer